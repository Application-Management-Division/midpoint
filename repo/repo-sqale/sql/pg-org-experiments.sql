/*
 * Copyright (C) 2010-2021 Evolveum and contributors
 *
 * This work is dual-licensed under the Apache License 2.0
 * and European Union Public License. See LICENSE file for details.
 *
 * @formatter:off because of terribly unreliable IDEA reformat for SQL
 */

/*
drop table xoid;

create table xoid as
select generate_series(1, 100) as id, gen_random_uuid() as oid;
*/

create table xoid (id bigint primary key, oid TEXT);
insert into xoid (select generate_series(1, 100) as id, md5(random()::TEXT) as oid);

select * from xoid;
/* "statistical" check that numbers from 1 to 10 are selected (including), no 0
select min(a), max(a)  --                |    |
from (select width_bucket(random(), 0,   1,   10) as a from generate_series(1, 20000)) q;
*/

select width_bucket(random(), 0, 1, 100);
select * from width_bucket(random(), 0, 1, 100);
select pg_typeof(width_bucket(random(), 0, 1, 100));

select * from xoid
    where xoid.id = width_bucket(random(), 0, 1, 100);

select * from xoid
    where xoid.id = (select width_bucket(random(), 0, 1, 100));

select * from
     (select b, width_bucket(random(), 0, 1, 100) id from generate_series(1,10) b) a
    left join xoid on xoid.id = a.id;

-- region OLD REPO experiments

-- This finds all the orgs for the user
-- in m_reference owner = child, target = parent
EXPLAIN (ANALYZE, VERBOSE, BUFFERS)
with recursive org_h (
    parent,
    child
) as (
    select r.targetoid, r.owner_oid from m_reference as r
        where r.reference_type = 0
            -- this condition makes it super fast, the same out of CTE is much slower
            and r.owner_oid = 'u7:21200-0...-....-....-............'
    union
    select par.targetoid, chi.child
        from m_reference as par, org_h as chi
        where par.reference_type = 0
            and par.owner_oid = chi.parent
)
select distinct parent from org_h
-- select * from org_h
--     where child = 'u7:21200-0...-....-....-............'
;

-- endregion

select * from m_ref_object_parent_org;
select * from m_object;
select * from m_uri;

set jit = off;

-- generated by Querydsl
EXPLAIN (ANALYZE, VERBOSE, BUFFERS)
with recursive orgc (parent, child) as not materialized (
    (select refpo.targetOid, refpo.owner_oid from m_ref_object_parent_org refpo)
    union
    (select refpo.targetOid, orgc.child from m_ref_object_parent_org refpo, orgc orgc where refpo.owner_oid = orgc.parent)
)
select po.name_orig, parent, child,
       co.name_orig,
       * from orgc
    join m_object po on po.oid = parent
    join m_object co on co.oid = child
;
select orgc.parent, orgc.child from orgc orgc
where orgc.child = gen_random_uuid() limit 10
;


-- bottom to top, we check for owner type only in the non-recursive term
drop materialized view m_org_closure;
create materialized view m_org_closure as
-- EXPLAIN (ANALYZE, VERBOSE, BUFFERS)
with recursive org_h (ancestor, descendant) as not materialized (
    -- gather all organizations with parents
    select r.targetoid, r.owner_oid
    from m_ref_object_parent_org r
    where r.owner_type = 'ORG'
    union
    -- generate their parents
    select par.targetoid, chi.descendant -- leaving original child there generates closure
    from m_ref_object_parent_org as par, org_h as chi
    where par.owner_oid = chi.ancestor
)
select count(*) from org_h;

refresh materialized view m_org_closure;